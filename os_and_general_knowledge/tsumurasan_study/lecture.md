今まで何やってた？？
* webサーバーにブラウザからアクセスした時に何が起こってるのかを細かく見ていこう
  * プロセスとスレッドの話
    * 親


並行
* 同時に複数処理が完全に1つの瞬間に同時に動く

並列
* 同時に複数処理が動く

プロセス
* kernel上でいうと単なるメモリ


スレッド
* プロセス、メモリがある
  * スレッドはプロセスのメモリを共有している状態
* メインスレッド

rubyで作れるので触ってみてもいいかも。

cで基礎的なお試し
pritf -> 標準出力。どこに出力するかを省略する
== fprintf(stdout)
stdout と stderr はどう違う？？

printf write 系、何が違う？？
C言語系のライブラリがある
* どのOSでも使える
  * コンパイラは変わるけど
  * なんで？？、OSごとに機能は異なるのに
* OS固有のものがある 
  * system call
    * OSの機能を利用している
    * write は OS固有の機能
      * 0, 1, 2
      * stdin, stdout, stderr
      * file discripter
出力さき
標準出力と標準エラーがある
1 2 に表示される > terminal に表示されている
hoge 1> /dev/null
--> 標準出力を出力、その後の結果だけがterminalに出力される

cの関数
成功したら 1
失敗したら -の値

main 関数
0 が正常
1 異常がエラー

terminal上のコマンド処理
- && -> 正常終了、0のステータスが帰った場合
  - 実は256も同じ、正常終了として
  - intを返す
    - 下2バイトのみを使う
    - 256 下2バイトを使うので、両方とも0という判断になってしまう
      - ということは他にもそうなりうる数字がありそう
- || -> 異常終了

| パイプ
* stdin と stdout を使って遊んでみる
* これが、unixの各コマンドで実際に行われていること


アセンブラとコンパイルについて
* gcc
  * -o アウトプットファイル 対象ファイル
  * コンパイルするとアセンブラファイルがsyuturyokusareru
  * -S アセンブリまでで止まる

c > アセンブラのファイル > オブジェクトのファイル > 実行ファイル(.exe)
コンパイル                                 リンク

実はちょっと違う
gcc -E オプションでちょっと違うのがみれる、ヘッダーファイルを展開する役割
c > ちょっと違うc > アセンブラのファイル > オブジェクト（機械語）のファイル（が複数できている） > 実行ファイル(.exe)
コンパイル                                                       リンク

プリプロセッサーというものがある
* 変数やメソッドが展開される
* ヘッダー部分を置き換える作業が、ちょっと違うcにする作業で行われている

アセンブラ、CPUの命令セットを人間に読める形に翻訳した言語
アセンブラ = 機械語を人間に読める形に置き換えただけの話

本質的にやっていることは文字列の置き換え。コンパイラがやっていること。

RubyやJSのインタプリタ
* コードを読み取って、解析する
* 読み取ったデータ、構造化されたデータに変える
  * その変えたデータを実行する
  * gekko の最初の方のJS（とその実行エンジン）、実はCでできている

次回
ファイルストリーム、IPCの話とかにもどる？？
シグナル、割り込みの話？？
* Streamで繋がるUNIX（ちょっとやった）
  * ファイル、ネット
* プロセス、スレッド。処理単位をどうやって作っていくのかという話（ちょっとやった
  * 複数の処理をどうさばくか
* 割り込み処理
  * プロセスが外部からコントロールする方法
  * killコマンドとか
* Stream プロセス・スレッドに関係する多重IO

2021-02-04 4回
Linux の directory構造
* FHSという仕様がある。
  * 統一されていないとプログラムをマルチ環境で動かすのが困難なる。
* gcc で math library を使う場合
  * ライブラリーがどこに置かれているのか、場所を特定するのかが難しい
  * 大体、システム側で用意している
    * /lib 配下
      * /lib32 /lib64 
      * $PATH はシステム側で用意しているパスの一覧
  * /bin/ 後から入れるところではない。システム側が提供してくれるもの
    * 一番権限が高いところ
  * /sbin superuserのs rootuserが使うところ。一般ユーザーでは基本的に実行できないライブラリ
  * /usr/bin 一般ユーザーが使うもの。/binと違い必須では（）が、よく使うやつは入れている
    * 昔はここに実行ファイルを配置したりした
  * /media /mnt マウントした
  * /dev デバイスをファイルとして見せかけているやつ
    * 特定のデバイスをここでコントロールできる
    * ここを変更すると、ドライバーが起動し、操作されだす
  * /opt optional 各ユーザーがそれぞれ入れられる
  * /boot OSを起動する前に動くので、ここをいじると危ない
* 細かくは仕様書で 

コンパイラのリンク
* ここを理解すると、mysqlビルドに失敗して、どうしたらいいか分からない問題が朧げに理解できるかも
* gcc
  * ファイルを分割する時、ファイルをガーーっとつなげるだけで良い
  * /lib/lib** でファイル名を探しにいく
    * lib** というファイル、共有、sharedファイルと言われる
  宅配便で抜けた
  * headerファイル、実行ファイルがある
  * -L lhoge がないと見に行かない。デフォルトのパスにはないので読み込めない
  * LD_LIBRARY_PATH を一時的に追加する
* mysql、システムによってどこに入っているのか分からない。homebrewだとdefaultのところに入ってくれない
  * /usr/local/celler に入る、buildしたりするとまた場所が変わる
  * なので、場所が見つからずエラーになる
* OpenSSLもそう
* なのでこの時に -L オプションをつけましょうと出てくるが、これはそういう話
 がないと見に行かない。デフォルトのパスにはないので読み込めない
  * LD_LIBRARY_PATHを一時的に追加する
* mysql、システムによってどこに入っているのか分からない。homebrewだとdefaultのところに入ってくれない
  * /usr/local/celler に入る、buildしたりするとまた場所が変わる
  * なので、場所が見つからずエラーになる
  * ＄PATH 実行ファイルのパス
  * LD_LIBRALY_PATH ライブラリー読み込み時に探すパス    
* ファイルがあるけれど使われていないというケースに役立つ
  * pathの優先順位、場合によっては危ない

* argv 実行ファイル名を変えられる
  * memcpyも併用
    * これを使って実行ファイル自体は同じだけど動作としては違うコマンドを使える様にするために使える
  * フラグ的に使える

 * FHSに戻る
  * /proc
    * プロセスの情報がファイルとして存在する場所
    * /cpuinfo というファイル
      * UNIXが哲学。ファイルとして情報をやりとりする。PCのCPU情報がファイル内にまとめられている
    * /version
* ps aux でプロセスIDが測
* FHSの仕様を少し見てみるれる
  * ここから、/procディレクトリないに実際の実行ファイルを見に行ける

次回、割り込み、シグナルの話をする。



復習としてやっておくこと
* ディレクトリ構成についての復習
* FHSの仕様を少し見てみる
  * https://ja.wikipedia.org/wiki/Filesystem_Hierarchy_Standard#cite_note-20
* /proc の中身を見てみる
* 仮想環境でいたずらしてみる

* コンパイラのリンクに関して
* /proc の中身を見てみる
* 仮想環境でいたずらしてみる
* dotfiles

余談s
* OSI、ネットワークのレイヤーの話

## 第4回
## 目次
1. シグナルについて

* 目的の1つ
  * キーワードを頭の中に残して、その後の勉強の足掛かりにする

### 1. シグナルについて
まず、CPUレベルで関係してくる前提の話から
* キーボード入力
  * OSレベルで見たとき
  * メモリマップ
    * 特定の範囲のところに、CPUにつながってる外部メモリ、USB、LAN用の領域がある
      * 変化した場合、外部からの入力がわかるが、いつデータが入ってくるか分からない
        * 監視し続けるわけにはいかないので、変化があったら割り込んで、書き換える `割り込み処理`というものがある
          * ハードウェア割り込みと呼ばれる
          * プロセスの切り替えなんかもこれで行う
          * UNIX、これをOSの機能として取り込んだ。この機能のことをシグナルという
            * なんらかのメモリアクセス違反
              * ex, 閉じているファイルに対して書き込みをしようとした場合、エラーになる。次に進まない様にシグナルを発生させる
              * ex, 木ボードの入力
              * kill ターミナルからOSに対してシグナルを送る
                * 殺すためではなく、SIGNALを送る役目
                * ex, SIGNALはたくさんの種類がある SIG始まりの定数がたくさんある。中身は全て数字

SIGNALを受けるとプロセスはどうなるのか
man signal 
9 が kill シグナル
kill -9 kill -kill はこれが理由

killコマンド自体、プロセスにシグナルを送るコマンド
- -9（送るシグナル） 自体に意味がある
  - 一応、数字を直接渡すのではなく -kill という変数を渡すのがだいじ
- ctrl c 親プロセスにSIGCHILDが飛んだりする

nginx
サーバーに特定のSIGNALを送ると、デーモンを操作したりできる
* デーモン（守護神という意味らしい）
  * nginx を例に
    * ps aux
      * 出てくるのはプロセス
      * じゃあデーモン
        * 例、音声のコントロールをしてるやつ
        * プログラムが起動してからずっと起動しているやつ。常駐しているプログラムのこと
          * 通常は親プロセスが死ぬと子プロセスが死ぬ
            * 親プロセスは子プロセスの終了を待たないといけない
            * もし先に親が死ぬと、子プロセスは終了せず孤児になる。ゾンビプロセスと呼ばれるものが生まれる
              * いらないメモリを食い続けるので良い状態にはならない
              * こうならない様い、子プロセスの終了を待つ
          * 通常、プログラムはツリー嬢の関係になるが、そこから切り離される必要がある
            * デーモン、ツリーからき
            * 孫プロセス だけが常に動く
              * 孫まで常に作らないといけない、それが所定の手続き
              * 安全に動くゾンビプロセス
                * 本来、terminal から制御しているが、そうではなくなる。systemd
                  * 制御端末を持たない = 標準出力先がなくなる
                  * mysql とか docker-compose -d。本来 terminal を終了するとプロセスが終了するが、
                * 孫まで作らないとあまり良くないが、できるにはできるらしい
                  * ずっと動き続ける
* シグナルを送ると、色々操作できる
  * graceful shutdown
  * が、実際にプログラムからシグナルを送ることは難しい
    * SIGNAL中、本来使ってはいけない処理がある
    * 本来短い特定のピンポイント処理しかやってはいけない
      * 後からsignalを発生させるときに処理を書いてはいけない
      * man の説明の完全理解が必須
        * 便利だが非常に面倒

  
```
前回: OSを起動してからプロセスがどうやって動いてるのか

init d
```


2021/03/04


IOとパイプ

UNIX
- 団体の厳しいチェックがある。これを通るとこちらを名乗れる
  - macOS
  - Sun

Unix
- 公式の許可を取っていないもの
  - Linux
  - BSD


BSD
SySV
- cの関数レベルで互換性がない
  - 無駄な争いがあった
    - 融和があった。POSIXという規格が生まれた
      - Linuxはこちらにしたがっている
      - 両方の関数は両方で動く
  - その結果、windowsなどの別のOSに覇権を握られた

なので同じ関数でも複数あったりする。これはその互換性のため。

pollというコマンドがある

昔
1つのプロセスで複数のIOを扱うことができる。
この仕組みを多重IOという。

Webサーバー、1つのポートで待ち続ける必要がある。
これを簡単にできる。1つのポート番号でまち

ex, 複数のカメラで取ったデータをまとめて1つの動画として出力することが必要な場合など、こういうことが必要

分からないことまとめ
- ポート番号とプロセスの違い
- ファイルディスクリプターとは何か
- I/O、プロセス間通信。。
- ブロッキング動作

素振りに必要がありそうなこと
- IOプログラミング
  - 多重I/Oのありがたみが分かるかも


エンディアン
- Intel arm、互換性がない
  - そういう話が関係したりする

次回
- 半２重、ぜん2１０
- CPUとOSが違うのに何故通信できるのかという話
  - UNIXドメイン知識

- 127.0.0.1 と localhostの違い
  - etc, etc
Unix
